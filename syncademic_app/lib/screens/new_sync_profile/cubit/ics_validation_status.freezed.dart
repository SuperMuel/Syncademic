// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'ics_validation_status.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$IcsValidationStatus {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notValidated,
    required TResult Function() validationInProgress,
    required TResult Function(int? nbEvents) validated,
    required TResult Function(String? errorMessage) invalid,
    required TResult Function(String? errorMessage) validationFailed,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? notValidated,
    TResult? Function()? validationInProgress,
    TResult? Function(int? nbEvents)? validated,
    TResult? Function(String? errorMessage)? invalid,
    TResult? Function(String? errorMessage)? validationFailed,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notValidated,
    TResult Function()? validationInProgress,
    TResult Function(int? nbEvents)? validated,
    TResult Function(String? errorMessage)? invalid,
    TResult Function(String? errorMessage)? validationFailed,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NotValidated value) notValidated,
    required TResult Function(ValidationInProgress value) validationInProgress,
    required TResult Function(Validated value) validated,
    required TResult Function(Invalid value) invalid,
    required TResult Function(ValidationFailed value) validationFailed,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NotValidated value)? notValidated,
    TResult? Function(ValidationInProgress value)? validationInProgress,
    TResult? Function(Validated value)? validated,
    TResult? Function(Invalid value)? invalid,
    TResult? Function(ValidationFailed value)? validationFailed,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NotValidated value)? notValidated,
    TResult Function(ValidationInProgress value)? validationInProgress,
    TResult Function(Validated value)? validated,
    TResult Function(Invalid value)? invalid,
    TResult Function(ValidationFailed value)? validationFailed,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $IcsValidationStatusCopyWith<$Res> {
  factory $IcsValidationStatusCopyWith(
          IcsValidationStatus value, $Res Function(IcsValidationStatus) then) =
      _$IcsValidationStatusCopyWithImpl<$Res, IcsValidationStatus>;
}

/// @nodoc
class _$IcsValidationStatusCopyWithImpl<$Res, $Val extends IcsValidationStatus>
    implements $IcsValidationStatusCopyWith<$Res> {
  _$IcsValidationStatusCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$NotValidatedImplCopyWith<$Res> {
  factory _$$NotValidatedImplCopyWith(
          _$NotValidatedImpl value, $Res Function(_$NotValidatedImpl) then) =
      __$$NotValidatedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$NotValidatedImplCopyWithImpl<$Res>
    extends _$IcsValidationStatusCopyWithImpl<$Res, _$NotValidatedImpl>
    implements _$$NotValidatedImplCopyWith<$Res> {
  __$$NotValidatedImplCopyWithImpl(
      _$NotValidatedImpl _value, $Res Function(_$NotValidatedImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$NotValidatedImpl extends NotValidated {
  const _$NotValidatedImpl() : super._();

  @override
  String toString() {
    return 'IcsValidationStatus.notValidated()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$NotValidatedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notValidated,
    required TResult Function() validationInProgress,
    required TResult Function(int? nbEvents) validated,
    required TResult Function(String? errorMessage) invalid,
    required TResult Function(String? errorMessage) validationFailed,
  }) {
    return notValidated();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? notValidated,
    TResult? Function()? validationInProgress,
    TResult? Function(int? nbEvents)? validated,
    TResult? Function(String? errorMessage)? invalid,
    TResult? Function(String? errorMessage)? validationFailed,
  }) {
    return notValidated?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notValidated,
    TResult Function()? validationInProgress,
    TResult Function(int? nbEvents)? validated,
    TResult Function(String? errorMessage)? invalid,
    TResult Function(String? errorMessage)? validationFailed,
    required TResult orElse(),
  }) {
    if (notValidated != null) {
      return notValidated();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NotValidated value) notValidated,
    required TResult Function(ValidationInProgress value) validationInProgress,
    required TResult Function(Validated value) validated,
    required TResult Function(Invalid value) invalid,
    required TResult Function(ValidationFailed value) validationFailed,
  }) {
    return notValidated(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NotValidated value)? notValidated,
    TResult? Function(ValidationInProgress value)? validationInProgress,
    TResult? Function(Validated value)? validated,
    TResult? Function(Invalid value)? invalid,
    TResult? Function(ValidationFailed value)? validationFailed,
  }) {
    return notValidated?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NotValidated value)? notValidated,
    TResult Function(ValidationInProgress value)? validationInProgress,
    TResult Function(Validated value)? validated,
    TResult Function(Invalid value)? invalid,
    TResult Function(ValidationFailed value)? validationFailed,
    required TResult orElse(),
  }) {
    if (notValidated != null) {
      return notValidated(this);
    }
    return orElse();
  }
}

abstract class NotValidated extends IcsValidationStatus {
  const factory NotValidated() = _$NotValidatedImpl;
  const NotValidated._() : super._();
}

/// @nodoc
abstract class _$$ValidationInProgressImplCopyWith<$Res> {
  factory _$$ValidationInProgressImplCopyWith(_$ValidationInProgressImpl value,
          $Res Function(_$ValidationInProgressImpl) then) =
      __$$ValidationInProgressImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ValidationInProgressImplCopyWithImpl<$Res>
    extends _$IcsValidationStatusCopyWithImpl<$Res, _$ValidationInProgressImpl>
    implements _$$ValidationInProgressImplCopyWith<$Res> {
  __$$ValidationInProgressImplCopyWithImpl(_$ValidationInProgressImpl _value,
      $Res Function(_$ValidationInProgressImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ValidationInProgressImpl extends ValidationInProgress {
  const _$ValidationInProgressImpl() : super._();

  @override
  String toString() {
    return 'IcsValidationStatus.validationInProgress()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ValidationInProgressImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notValidated,
    required TResult Function() validationInProgress,
    required TResult Function(int? nbEvents) validated,
    required TResult Function(String? errorMessage) invalid,
    required TResult Function(String? errorMessage) validationFailed,
  }) {
    return validationInProgress();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? notValidated,
    TResult? Function()? validationInProgress,
    TResult? Function(int? nbEvents)? validated,
    TResult? Function(String? errorMessage)? invalid,
    TResult? Function(String? errorMessage)? validationFailed,
  }) {
    return validationInProgress?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notValidated,
    TResult Function()? validationInProgress,
    TResult Function(int? nbEvents)? validated,
    TResult Function(String? errorMessage)? invalid,
    TResult Function(String? errorMessage)? validationFailed,
    required TResult orElse(),
  }) {
    if (validationInProgress != null) {
      return validationInProgress();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NotValidated value) notValidated,
    required TResult Function(ValidationInProgress value) validationInProgress,
    required TResult Function(Validated value) validated,
    required TResult Function(Invalid value) invalid,
    required TResult Function(ValidationFailed value) validationFailed,
  }) {
    return validationInProgress(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NotValidated value)? notValidated,
    TResult? Function(ValidationInProgress value)? validationInProgress,
    TResult? Function(Validated value)? validated,
    TResult? Function(Invalid value)? invalid,
    TResult? Function(ValidationFailed value)? validationFailed,
  }) {
    return validationInProgress?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NotValidated value)? notValidated,
    TResult Function(ValidationInProgress value)? validationInProgress,
    TResult Function(Validated value)? validated,
    TResult Function(Invalid value)? invalid,
    TResult Function(ValidationFailed value)? validationFailed,
    required TResult orElse(),
  }) {
    if (validationInProgress != null) {
      return validationInProgress(this);
    }
    return orElse();
  }
}

abstract class ValidationInProgress extends IcsValidationStatus {
  const factory ValidationInProgress() = _$ValidationInProgressImpl;
  const ValidationInProgress._() : super._();
}

/// @nodoc
abstract class _$$ValidatedImplCopyWith<$Res> {
  factory _$$ValidatedImplCopyWith(
          _$ValidatedImpl value, $Res Function(_$ValidatedImpl) then) =
      __$$ValidatedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int? nbEvents});
}

/// @nodoc
class __$$ValidatedImplCopyWithImpl<$Res>
    extends _$IcsValidationStatusCopyWithImpl<$Res, _$ValidatedImpl>
    implements _$$ValidatedImplCopyWith<$Res> {
  __$$ValidatedImplCopyWithImpl(
      _$ValidatedImpl _value, $Res Function(_$ValidatedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? nbEvents = freezed,
  }) {
    return _then(_$ValidatedImpl(
      nbEvents: freezed == nbEvents
          ? _value.nbEvents
          : nbEvents // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc

class _$ValidatedImpl extends Validated {
  const _$ValidatedImpl({this.nbEvents}) : super._();

  @override
  final int? nbEvents;

  @override
  String toString() {
    return 'IcsValidationStatus.validated(nbEvents: $nbEvents)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ValidatedImpl &&
            (identical(other.nbEvents, nbEvents) ||
                other.nbEvents == nbEvents));
  }

  @override
  int get hashCode => Object.hash(runtimeType, nbEvents);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ValidatedImplCopyWith<_$ValidatedImpl> get copyWith =>
      __$$ValidatedImplCopyWithImpl<_$ValidatedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notValidated,
    required TResult Function() validationInProgress,
    required TResult Function(int? nbEvents) validated,
    required TResult Function(String? errorMessage) invalid,
    required TResult Function(String? errorMessage) validationFailed,
  }) {
    return validated(nbEvents);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? notValidated,
    TResult? Function()? validationInProgress,
    TResult? Function(int? nbEvents)? validated,
    TResult? Function(String? errorMessage)? invalid,
    TResult? Function(String? errorMessage)? validationFailed,
  }) {
    return validated?.call(nbEvents);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notValidated,
    TResult Function()? validationInProgress,
    TResult Function(int? nbEvents)? validated,
    TResult Function(String? errorMessage)? invalid,
    TResult Function(String? errorMessage)? validationFailed,
    required TResult orElse(),
  }) {
    if (validated != null) {
      return validated(nbEvents);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NotValidated value) notValidated,
    required TResult Function(ValidationInProgress value) validationInProgress,
    required TResult Function(Validated value) validated,
    required TResult Function(Invalid value) invalid,
    required TResult Function(ValidationFailed value) validationFailed,
  }) {
    return validated(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NotValidated value)? notValidated,
    TResult? Function(ValidationInProgress value)? validationInProgress,
    TResult? Function(Validated value)? validated,
    TResult? Function(Invalid value)? invalid,
    TResult? Function(ValidationFailed value)? validationFailed,
  }) {
    return validated?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NotValidated value)? notValidated,
    TResult Function(ValidationInProgress value)? validationInProgress,
    TResult Function(Validated value)? validated,
    TResult Function(Invalid value)? invalid,
    TResult Function(ValidationFailed value)? validationFailed,
    required TResult orElse(),
  }) {
    if (validated != null) {
      return validated(this);
    }
    return orElse();
  }
}

abstract class Validated extends IcsValidationStatus {
  const factory Validated({final int? nbEvents}) = _$ValidatedImpl;
  const Validated._() : super._();

  int? get nbEvents;
  @JsonKey(ignore: true)
  _$$ValidatedImplCopyWith<_$ValidatedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$InvalidImplCopyWith<$Res> {
  factory _$$InvalidImplCopyWith(
          _$InvalidImpl value, $Res Function(_$InvalidImpl) then) =
      __$$InvalidImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String? errorMessage});
}

/// @nodoc
class __$$InvalidImplCopyWithImpl<$Res>
    extends _$IcsValidationStatusCopyWithImpl<$Res, _$InvalidImpl>
    implements _$$InvalidImplCopyWith<$Res> {
  __$$InvalidImplCopyWithImpl(
      _$InvalidImpl _value, $Res Function(_$InvalidImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? errorMessage = freezed,
  }) {
    return _then(_$InvalidImpl(
      errorMessage: freezed == errorMessage
          ? _value.errorMessage
          : errorMessage // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$InvalidImpl extends Invalid {
  const _$InvalidImpl({required this.errorMessage}) : super._();

  @override
  final String? errorMessage;

  @override
  String toString() {
    return 'IcsValidationStatus.invalid(errorMessage: $errorMessage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InvalidImpl &&
            (identical(other.errorMessage, errorMessage) ||
                other.errorMessage == errorMessage));
  }

  @override
  int get hashCode => Object.hash(runtimeType, errorMessage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$InvalidImplCopyWith<_$InvalidImpl> get copyWith =>
      __$$InvalidImplCopyWithImpl<_$InvalidImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notValidated,
    required TResult Function() validationInProgress,
    required TResult Function(int? nbEvents) validated,
    required TResult Function(String? errorMessage) invalid,
    required TResult Function(String? errorMessage) validationFailed,
  }) {
    return invalid(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? notValidated,
    TResult? Function()? validationInProgress,
    TResult? Function(int? nbEvents)? validated,
    TResult? Function(String? errorMessage)? invalid,
    TResult? Function(String? errorMessage)? validationFailed,
  }) {
    return invalid?.call(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notValidated,
    TResult Function()? validationInProgress,
    TResult Function(int? nbEvents)? validated,
    TResult Function(String? errorMessage)? invalid,
    TResult Function(String? errorMessage)? validationFailed,
    required TResult orElse(),
  }) {
    if (invalid != null) {
      return invalid(errorMessage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NotValidated value) notValidated,
    required TResult Function(ValidationInProgress value) validationInProgress,
    required TResult Function(Validated value) validated,
    required TResult Function(Invalid value) invalid,
    required TResult Function(ValidationFailed value) validationFailed,
  }) {
    return invalid(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NotValidated value)? notValidated,
    TResult? Function(ValidationInProgress value)? validationInProgress,
    TResult? Function(Validated value)? validated,
    TResult? Function(Invalid value)? invalid,
    TResult? Function(ValidationFailed value)? validationFailed,
  }) {
    return invalid?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NotValidated value)? notValidated,
    TResult Function(ValidationInProgress value)? validationInProgress,
    TResult Function(Validated value)? validated,
    TResult Function(Invalid value)? invalid,
    TResult Function(ValidationFailed value)? validationFailed,
    required TResult orElse(),
  }) {
    if (invalid != null) {
      return invalid(this);
    }
    return orElse();
  }
}

abstract class Invalid extends IcsValidationStatus {
  const factory Invalid({required final String? errorMessage}) = _$InvalidImpl;
  const Invalid._() : super._();

  String? get errorMessage;
  @JsonKey(ignore: true)
  _$$InvalidImplCopyWith<_$InvalidImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ValidationFailedImplCopyWith<$Res> {
  factory _$$ValidationFailedImplCopyWith(_$ValidationFailedImpl value,
          $Res Function(_$ValidationFailedImpl) then) =
      __$$ValidationFailedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String? errorMessage});
}

/// @nodoc
class __$$ValidationFailedImplCopyWithImpl<$Res>
    extends _$IcsValidationStatusCopyWithImpl<$Res, _$ValidationFailedImpl>
    implements _$$ValidationFailedImplCopyWith<$Res> {
  __$$ValidationFailedImplCopyWithImpl(_$ValidationFailedImpl _value,
      $Res Function(_$ValidationFailedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? errorMessage = freezed,
  }) {
    return _then(_$ValidationFailedImpl(
      errorMessage: freezed == errorMessage
          ? _value.errorMessage
          : errorMessage // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$ValidationFailedImpl extends ValidationFailed {
  const _$ValidationFailedImpl({required this.errorMessage}) : super._();

  @override
  final String? errorMessage;

  @override
  String toString() {
    return 'IcsValidationStatus.validationFailed(errorMessage: $errorMessage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ValidationFailedImpl &&
            (identical(other.errorMessage, errorMessage) ||
                other.errorMessage == errorMessage));
  }

  @override
  int get hashCode => Object.hash(runtimeType, errorMessage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ValidationFailedImplCopyWith<_$ValidationFailedImpl> get copyWith =>
      __$$ValidationFailedImplCopyWithImpl<_$ValidationFailedImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notValidated,
    required TResult Function() validationInProgress,
    required TResult Function(int? nbEvents) validated,
    required TResult Function(String? errorMessage) invalid,
    required TResult Function(String? errorMessage) validationFailed,
  }) {
    return validationFailed(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? notValidated,
    TResult? Function()? validationInProgress,
    TResult? Function(int? nbEvents)? validated,
    TResult? Function(String? errorMessage)? invalid,
    TResult? Function(String? errorMessage)? validationFailed,
  }) {
    return validationFailed?.call(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notValidated,
    TResult Function()? validationInProgress,
    TResult Function(int? nbEvents)? validated,
    TResult Function(String? errorMessage)? invalid,
    TResult Function(String? errorMessage)? validationFailed,
    required TResult orElse(),
  }) {
    if (validationFailed != null) {
      return validationFailed(errorMessage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NotValidated value) notValidated,
    required TResult Function(ValidationInProgress value) validationInProgress,
    required TResult Function(Validated value) validated,
    required TResult Function(Invalid value) invalid,
    required TResult Function(ValidationFailed value) validationFailed,
  }) {
    return validationFailed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NotValidated value)? notValidated,
    TResult? Function(ValidationInProgress value)? validationInProgress,
    TResult? Function(Validated value)? validated,
    TResult? Function(Invalid value)? invalid,
    TResult? Function(ValidationFailed value)? validationFailed,
  }) {
    return validationFailed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NotValidated value)? notValidated,
    TResult Function(ValidationInProgress value)? validationInProgress,
    TResult Function(Validated value)? validated,
    TResult Function(Invalid value)? invalid,
    TResult Function(ValidationFailed value)? validationFailed,
    required TResult orElse(),
  }) {
    if (validationFailed != null) {
      return validationFailed(this);
    }
    return orElse();
  }
}

abstract class ValidationFailed extends IcsValidationStatus {
  const factory ValidationFailed({required final String? errorMessage}) =
      _$ValidationFailedImpl;
  const ValidationFailed._() : super._();

  String? get errorMessage;
  @JsonKey(ignore: true)
  _$$ValidationFailedImplCopyWith<_$ValidationFailedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
